# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Virtual environments
.venv/
venv/
ENV/

# Node
node_modules/

# OS files
.DS_Store
Thumbs.db

# Editors
.vscode/
.idea/

# Python packaging
dist/
build/
.eggs/
*.egg-info/

# Logs
logs/
*.log

# dotenv
.env
.env.*
EOF
# .env.example
cat > .env.example <<\"EOF\"
DASH_PASSWORD=change_me
RITHMIC_USERNAME=
RITHMIC_PASSWORD=
RITHMIC_SYSTEM=Rithmic01PaperTrading
RITHMIC_LOCATION=Chicago_Azure
DELTA_CONFIDENCE_THRESHOLD=0.6
EOF
# pyproject.toml
cat > pyproject.toml <<\"EOF\"
[tool.poetry]
name = "smm-nq-trader"
version = "0.1.0"
description = "Ultra-low latency auto-trading platform for NQ futures"
authors = ["Your Name <you@example.com>"]

[tool.poetry.dependencies]
python = "^3.12"
uvloop = "^0.20.0"
fastapi = "^0.115.0"
uvicorn = "^0.30.0"
websockets = "^12.0"
pyyaml = "^6.0.2"
pandas = "^2.2.2"
numpy = "^2.1.1"
async-rithmic = "*"
httpx = "^0.27.2"

[tool.poetry.group.dev.dependencies]
pytest = "^8.3.3"
pytest-asyncio = "^0.24.0"
black = "^24.8.0"
ruff = "^0.6.2"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
EOF
# config/config.yaml
cat > config/config.yaml <<\"EOF\"
version: 1
log_level: INFO
latency_probes: true
usernames:
  - name: default
    enabled: true
    reconnect_backoff_ms: [100, 250, 500, 1000, 2000]
    subscriptions:
      symbols: [NQZ5, MNQZ5]
      depth: 10
      mbo: true
    risk:
      max_daily_drawdown: 250.0
      max_position: 4
      max_orders_per_minute: 60
      max_slippage_ticks: 2
    strategy:
      ema_period: 21
      delta_confidence_threshold: 0.6
      bracket:
        target_ticks: 20
        stop_ticks: 12
        trail_on_momentum: true
accounts_file: accounts/accounts.yaml
state_dir: storage/state
EOF
# accounts/accounts.yaml
cat > accounts/accounts.yaml <<\"EOF\"
usernames:
  - name: default
    accounts:
      - id: Apex11111-01
        enabled: true
      - id: Apex11111-02
        enabled: true
EOF
# __init__.py files
printf "__all__ = []\n" > core/__init__.py
printf "__all__ = []\n" > rithmic/__init__.py
printf "__all__ = []\n" > exec/__init__.py
printf "__all__ = []\n" > web/__init__.py
printf "__all__ = []\n" > storage/__init__.py
printf "__all__ = []\n" > tests/__init__.py
# core/buffers.py
cat > core/buffers.py <<\"PY\"
import numpy as np
from typing import Optional

class RingBuffer:
    def __init__(self, capacity: int) -> None:
        self.capacity = capacity
        self.buffer = np.zeros(capacity, dtype=np.float64)
        self.index = 0
        self.size = 0

    def append(self, value: float) -> None:
        self.buffer[self.index] = value
        self.index = (self.index + 1) % self.capacity
        self.size = min(self.size + 1, self.capacity)

    def values(self) -> np.ndarray:
        if self.size < self.capacity:
            return self.buffer[:self.size]
        return np.concatenate((self.buffer[self.index:], self.buffer[:self.index]))

class Ema:
    def __init__(self, period: int) -> None:
        self.alpha = 2.0 / (period + 1)
        self.prev: Optional[float] = None
        self.prev_prev: Optional[float] = None

    def update(self, price: float) -> float:
        if self.prev is None:
            self.prev = price
            self.prev_prev = price
        else:
            self.prev_prev = self.prev
            self.prev = (price - self.prev) * self.alpha + self.prev
        return self.prev

    def slope(self) -> float:
        if self.prev is None or self.prev_prev is None:
            return 0.0
        return self.prev - self.prev_prev
PY
# core/features.py
cat > core/features.py <<\"PY\"
import numpy as np
from dataclasses import dataclass
from typing import Dict, Optional

from .buffers import RingBuffer

@dataclass
class FeatureSnapshot:
    cvd: float
    cvd_slope: float
    depth_imbalance: float
    depth_slope: float
    aggressive_buy_ratio: float
    delta_confidence: float

class FeatureEngine:
    def __init__(self, window: int = 256, weights: Optional[Dict[str, float]] = None) -> None:
        self.buy_volume = RingBuffer(window)
        self.sell_volume = RingBuffer(window)
        self.cvd_series = RingBuffer(window)
        self.depth_imbalance_series = RingBuffer(window)
        self.depth_slope_series = RingBuffer(window)
        self.weights = weights or {
            "cvd_slope": 0.4,
            "depth_imbalance": 0.3,
            "aggressive_buy_ratio": 0.3,
        }
        self._cvd = 0.0

    def update_trades(self, buy_qty: float, sell_qty: float) -> None:
        self.buy_volume.append(buy_qty)
        self.sell_volume.append(sell_qty)
        self._cvd += (buy_qty - sell_qty)
        self.cvd_series.append(self._cvd)

    def update_orderbook(self, bid_qty_levels: np.ndarray, ask_qty_levels: np.ndarray) -> None:
        bid_sum = float(np.sum(bid_qty_levels)) + 1e-9
        ask_sum = float(np.sum(ask_qty_levels)) + 1e-9
        depth_imbalance = (bid_sum - ask_sum) / (bid_sum + ask_sum)
        self.depth_imbalance_series.append(depth_imbalance)

        weights = np.arange(1, len(bid_qty_levels) + 1, dtype=np.float64)
        bid_weighted = float(np.dot(bid_qty_levels, weights))
        ask_weighted = float(np.dot(ask_qty_levels, weights))
        depth_slope = (bid_weighted - ask_weighted) / (bid_weighted + ask_weighted + 1e-9)
        self.depth_slope_series.append(depth_slope)

    def _slope(self, series: RingBuffer) -> float:
        vals = series.values()
        if len(vals) < 2:
            return 0.0
        x = np.arange(len(vals), dtype=np.float64)
        x_mean = np.mean(x)
        y_mean = np.mean(vals)
        num = float(np.dot(x - x_mean, vals - y_mean))
        den = float(np.dot(x - x_mean, x - x_mean)) + 1e-9
        return num / den

    def snapshot(self) -> FeatureSnapshot:
        cvd_slope = self._slope(self.cvd_series)
        depth_imbalance = (self.depth_imbalance_series.values()[-1] if self.depth_imbalance_series.size else 0.0)
        depth_slope = (self.depth_slope_series.values()[-1] if self.depth_slope_series.size else 0.0)
        buys = self.buy_volume.values()
        sells = self.sell_volume.values()
        total_buys = float(np.sum(buys))
        total_sells = float(np.sum(sells))
        aggressive_buy_ratio = total_buys / (total_buys + total_sells + 1e-9)

        def squash(x: float) -> float:
            return 1.0 / (1.0 + np.exp(-x))

        w = self.weights
        score = (
            w["cvd_slope"] * (squash(cvd_slope) - 0.5) * 2.0 +
            w["depth_imbalance"] * depth_imbalance +
            w["aggressive_buy_ratio"] * (aggressive_buy_ratio - 0.5) * 2.0
        )
        delta_confidence = max(0.0, min(1.0, 0.5 * (score + 1.0)))

        return FeatureSnapshot(
            cvd=self._cvd,
            cvd_slope=cvd_slope,
            depth_imbalance=depth_imbalance,
            depth_slope=depth_slope,
            aggressive_buy_ratio=aggressive_buy_ratio,
            delta_confidence=delta_confidence,
        )
PY
# core/signals.py
cat > core/signals.py <<\"PY\"
from dataclasses import dataclass
from typing import Optional

from .buffers import Ema
from .features import FeatureSnapshot

@dataclass
class SignalDecision:
    side: Optional[str]
    delta_confidence: float
    ema: float
    ema_slope: float

class SignalEngine:
    def __init__(self, ema_period: int = 21, delta_threshold: float = 0.6) -> None:
        self.ema = Ema(ema_period)
        self.delta_threshold = delta_threshold

    def on_price_and_features(self, last_price: float, features: FeatureSnapshot) -> SignalDecision:
        ema_val = self.ema.update(last_price)
        ema_slope = self.ema.slope()
        allowed_long = last_price > ema_val and ema_slope >= 0.0
        allowed_short = last_price < ema_val and ema_slope <= 0.0
        side: Optional[str] = None
        if features.delta_confidence >= self.delta_threshold and allowed_long:
            side = "BUY"
        elif (1.0 - features.delta_confidence) >= self.delta_threshold and allowed_short:
            side = "SELL"
        return SignalDecision(side=side, delta_confidence=features.delta_confidence, ema=ema_val, ema_slope=ema_slope)
PY
# exec/executor.py
cat > exec/executor.py <<\"PY\"
import uuid
from dataclasses import dataclass
from typing import Dict, List

@dataclass
class OrderIntent:
    account_id: str
    symbol: str
    side: str  # BUY/SELL
    qty: int
    client_order_id: str
    target_ticks: int
    stop_ticks: int

class ExecutionEngine:
    def __init__(self) -> None:
        self.account_enabled: Dict[str, bool] = {}
        self.open_orders: Dict[str, Dict[str, OrderIntent]] = {}

    def set_accounts(self, accounts: List[str]) -> None:
        for acc in accounts:
            self.account_enabled[acc] = True
            self.open_orders.setdefault(acc, {})

    def _new_client_order_id(self, account_id: str) -> str:
        return f"{account_id}-{uuid.uuid4().hex[:12]}"

    async def submit_signal(self, symbol: str, side: str, qty: int, target_ticks: int, stop_ticks: int, accounts: List[str]) -> List[OrderIntent]:
        intents: List[OrderIntent] = []
        for acc in accounts:
            if not self.account_enabled.get(acc, False):
                continue
            coid = self._new_client_order_id(acc)
            intent = OrderIntent(
                account_id=acc, symbol=symbol, side=side, qty=qty, client_order_id=coid, target_ticks=target_ticks, stop_ticks=stop_ticks
            )
            self.open_orders[acc][coid] = intent
            intents.append(intent)
        return intents

    async def on_fill(self, account_id: str, client_order_id: str, fill_qty: int, fill_price: float) -> None:
        pass

    async def reconcile_account(self, account_id: str) -> None:
        pass
PY
# exec/reconciler.py
cat > exec/reconciler.py <<\"PY\"
from typing import Dict

class Reconciler:
    def __init__(self) -> None:
        self.account_health: Dict[str, str] = {}

    async def reconcile(self, account_id: str) -> None:
        self.account_health[account_id] = "ok"

    async def global_flatten(self) -> None:
        pass
PY
# web/server.py
cat > web/server.py <<\"PY\"
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
import os

app = FastAPI()

def _auth(password: str) -> None:
    if password != os.getenv("DASH_PASSWORD", ""):
        raise HTTPException(status_code=401, detail="Unauthorized")

@app.get("/")
async def root():
    return {"status": "ok"}

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        await websocket.send_json({"hello": "world"})
        while True:
            _ = await websocket.receive_text()
    except WebSocketDisconnect:
        pass
PY
# rithmic/client.py (skeleton referencing async-rithmic architecture)
cat > rithmic/client.py <<\"PY\"
import asyncio
import os
from dataclasses import dataclass, field
from typing import Dict, List

import uvloop

# from async_rithmic import RithmicClient, TickerPlant, OrderPlant, PnLPlant  # library integration point

@dataclass
class Subscription:
    symbol: str
    depth: int
    mbo: bool

@dataclass
class UsernameSession:
    username: str
    password: str
    system: str
    location: str
    connected: bool = False
    desired_subs: Dict[str, Subscription] = field(default_factory=dict)

class RithmicOrchestrator:
    def __init__(self) -> None:
        self.sessions: Dict[str, UsernameSession] = {}

    async def ensure_session(self, username: str, password: str, system: str, location: str) -> UsernameSession:
        sess = self.sessions.get(username)
        if not sess:
            sess = UsernameSession(username=username, password=password, system=system, location=location)
            self.sessions[username] = sess
        if not sess.connected:
            # Here we would connect RithmicClient and plants, attach callbacks, start tasks
            sess.connected = True
        return sess

    async def subscribe(self, username: str, symbol: str, depth: int, mbo: bool) -> None:
        sess = self.sessions[username]
        sess.desired_subs[symbol] = Subscription(symbol=symbol, depth=depth, mbo=mbo)
        # If connected, register with ticker plant; on reconnect, iterate desired_subs to re-register

    async def run(self) -> None:
        while True:
            # Monitor connectivity, re-subscribe on reconnects, handle backoff
            await asyncio.sleep(0.5)

async def main() -> None:
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    username = os.getenv("RITHMIC_USERNAME", "")
    password = os.getenv("RITHMIC_PASSWORD", "")
    system = os.getenv("RITHMIC_SYSTEM", "Rithmic01PaperTrading")
    location = os.getenv("RITHMIC_LOCATION", "Chicago_Azure")

    orch = RithmicOrchestrator()
    await orch.ensure_session(username, password, system, location)
    await orch.run()

if __name__ == "__main__":
    asyncio.run(main())
PY
# storage/replay.py
cat > storage/replay.py <<\"PY\"
from typing import Iterable, Tuple

class ReplaySource:
    def __init__(self, lines: Iterable[str]) -> None:
        self._lines = iter(lines)

    def __iter__(self):
        return self

    def __next__(self) -> Tuple[str, float, float]:
        line = next(self._lines)
        # example format: "TS,buy_qty,sell_qty"
        ts, b, s = line.strip().split(",")
        return ts, float(b), float(s)
PY
# tests/test_features.py
cat > tests/test_features.py <<\"PY\"
import numpy as np
from core.features import FeatureEngine

def test_feature_engine_basic():
    fe = FeatureEngine(window=4)
    fe.update_trades(10, 5)
    fe.update_trades(0, 5)
    fe.update_orderbook(np.array([10, 9]), np.array([8, 7]))
    snap = fe.snapshot()
    assert 0.0 <= snap.delta_confidence <= 1.0
PY
# Dockerfiles and compose
cat > docker/Dockerfile.dashboard <<\"EOF\"
FROM python:3.12-slim
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
WORKDIR /app
COPY pyproject.toml /app/
RUN pip install --no-cache-dir poetry && poetry config virtualenvs.create false && poetry install --no-root --no-interaction --no-ansi
COPY . /app
CMD ["uvicorn", "web.server:app", "--host", "0.0.0.0", "--port", "8080"]
EOF

cat > docker/Dockerfile.trader <<\"EOF\"
FROM python:3.12-slim
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
WORKDIR /app
COPY pyproject.toml /app/
RUN pip install --no-cache-dir poetry && poetry config virtualenvs.create false && poetry install --no-root --no-interaction --no-ansi
COPY . /app
CMD ["python", "-m", "rithmic.client"]
EOF

cat > docker-compose.yml <<\"EOF\"
services:
  trader:
    build:
      context: .
      dockerfile: docker/Dockerfile.trader
    env_file: .env
    network_mode: host
    restart: unless-stopped
  dashboard:
    build:
      context: .
      dockerfile: docker/Dockerfile.dashboard
    env_file: .env
    ports:
      - 8080:8080
    restart: unless-stopped
EOF
