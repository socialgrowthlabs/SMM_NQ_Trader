from __future__ import annotations\n\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Deque, Optional, Tuple\n\n\nclass ECandleColoringType(str, Enum):\n    ProfitWave = "ProfitWave"\n    Trend = "Trend"\n\n\nclass EExtendMethod(str, Enum):\n    Touch = "Touch"\n    Close = "Close"\n\n\nclass ERealPriceLineWidth(str, Enum):\n    Thin = "Thin"\n    Thick = "Thick"\n\n\nclass ERealCloseSize(str, Enum):\n    Auto = "Auto"\n    Small = "Small"\n    Large = "Large"\n\n\nclass EMode(str, Enum):\n    None_ = "None"\n    Buy = "Buy"\n    Sell = "Sell"\n\n\nclass EMovingAverageType(str, Enum):\n    SMA = "SMA"\n    EMA = "EMA"\n\n\nclass EDataSource(str, Enum):\n    Price = "Price"\n    HeikenAshi = "HeikenAshi"\n\n\n@dataclass\nclass SupportResistanceLevel:\n    is_support: bool\n    from_bar: int\n    level: float\n    upto_bar: int\n    is_active: bool = True\n\n\nclass ExponentialMA:\n    def __init__(self, period: int) -> None:\n        if period <= 0:\n            raise ValueError("EMA period must be positive")\n        self.period = period\n        self.constant1 = 2.0 / (1.0 + period)\n        self.constant2 = 1.0 - self.constant1\n        self.previous_ema: Optional[float] = None\n\n    def update(self, value: float) -> float:\n        if self.previous_ema is None:\n            self.previous_ema = value\n        else:\n            self.previous_ema = value * self.constant1 + self.constant2 * self.previous_ema\n        return self.previous_ema\n\n\nclass AverageTrueRange:\n    def __init__(self, period: int) -> None:\n        if period <= 0:\n            raise ValueError("ATR period must be positive")\n        self.period = period\n        self.sample_count = 0\n        self.previous_close: Optional[float] = None\n        self.previous_atr: float = 0.0\n\n    def update(self, high: float, low: float, close: float) -> float:\n        if self.previous_close is None:\n            true_range = high - low\n        else:\n            true_range = max(abs(low - self.previous_close), max(high - low, abs(high - self.previous_close)))\n        self.sample_count += 1\n        window = min(self.sample_count, self.period)\n        if self.sample_count == 1:\n            atr = true_range\n        else:\n            atr = ((window - 1) * self.previous_atr + true_range) / window\n        self.previous_close = close\n        self.previous_atr = atr\n        return atr\n\n\nclass MoneyFlowIndex:\n    def __init__(self, period: int) -> None:\n        if period <= 1:\n            raise ValueError("MFI period must be > 1")\n        self.period = period\n        self.typical_price_window: Deque[float] = deque(maxlen=period + 1)\n        self.volume_window: Deque[float] = deque(maxlen=period + 1)\n        self.current_value: float = float("nan")\n\n    def update(self, high: float, low: float, close: float, volume: float) -> float:\n        typical_price = (high + low + close) / 3.0\n        self.typical_price_window.appendleft(typical_price)\n        self.volume_window.appendleft(volume)\n        if len(self.typical_price_window) < self.period + 1:\n            self.current_value = float("nan")\n            return self.current_value\n        positive_flow = 0.0\n        negative_flow = 0.0\n        for i in range(self.period):\n            tp_curr = self.typical_price_window[i]\n            tp_prev = self.typical_price_window[i + 1]\n            vol = self.volume_window[i]\n            if tp_curr > tp_prev:\n                positive_flow += vol * tp_curr\n            elif tp_curr < tp_prev:\n                negative_flow += vol * tp_curr\n        if negative_flow > 0.0:\n            mfr = positive_flow / negative_flow\n            self.current_value = 100.0 - (100.0 / (1.0 + mfr))\n        else:\n            self.current_value = 0.0\n        return self.current_value\n\n\n@dataclass\nclass HeikenAshiState:\n    open: Optional[float] = None\n    high: Optional[float] = None\n    low: Optional[float] = None\n    close: Optional[float] = None\n\n\ndef update_heiken_ashi(state: HeikenAshiState, src_open: float, src_high: float, src_low: float, src_close: float) -> Tuple[float, float, float, float]:\n    if state.open is None:\n        ha_close = (src_open + src_high + src_low + src_close) * 0.25\n        ha_open = src_open\n        ha_high = src_high\n        ha_low = src_low\n    else:\n        ha_close = (src_open + src_high + src_low + src_close) * 0.25\n        ha_open = (state.open + state.close) * 0.5\n        ha_high = max(src_high, ha_open)\n        ha_low = min(src_low, ha_open)\n    state.open, state.high, state.low, state.close = ha_open, ha_high, ha_low, ha_close\n    return ha_open, ha_high, ha_low, ha_close\n